#!/usr/bin/env python3
#
# This file is part of Cookiescope.
#
# Cookiescope is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Cookiescope is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Cookiescope.  If not, see <https://www.gnu.org/licenses/>.

"""
Cookie scope.

Queries and displays browser cookies.

See command line help text for more information.

Binary cookies parsing code was originally based on this project:

https://github.com/ktnjared/BinaryCookieReader.git

It has been heavily modified and expanded here. The original code is probably
not recognizable at this point.
"""

import argparse
import os
import sqlite3
import sys
from abc import ABC, abstractmethod
from collections import namedtuple
from configparser import ConfigParser
from contextlib import contextmanager
from io import BytesIO
from pathlib import Path
from struct import unpack
from time import strftime, gmtime
from typing import AnyStr, IO, Iterable, Iterator, Self
from urllib.parse import unquote

#: Command line help description.
CLI_DESCRIPTION = 'Cookie query tool.'
#: Command line help epilog text.
CLI_EPILOG = '''
Cookie source can be a browser name, e.g. "safari", or a cookies file path. A
browser name can followed by ":<profile>" to specify a user profile. E.g.
"firefox:lucy" targets the Firefox profile named "lucy". Otherwise it works with
the default profile.

Filter values match full or partial attribute values. Multiple filter values can
be comma-separated. For the comparison, filter values are HTTP-quoted and
lower-cased, and cookie fields are HTTP-unquoted and also lower-cased.

If you have problems accessing an existing cookies file try quitting all running
browser processes. Some processes may be running in the background, even when
there are no visible windows.

Frequently-used attribute names:
  * value - primary cookie data field
  * name - cookie name
  * domain - website domain responsible for cookie
  * path - website location path string

The following named browsers are supported:
'''.strip()
#: Cookie source argument help.
COOKIE_SOURCE_HELP = 'cookies path or browser[:profile]'
FILTER_HELP = 'name=value expression for filtering on cookie fields'
#: Cookie type (plain string dictionary).
Cookie = dict[str, str]
#: ORed attribute filter values.
Filter = tuple[str, list[str]]
#: ANDed filters.
FilterBy = Iterable[Filter]
#: Sort by as sequence of attribute names.
SortBy = Iterable[str]
#: Mapping of platform to possible file locations.
LocationMap = dict[str, Iterable[str | Path]]
#: Default attribute sort by "clause".
DEFAULT_SORT_BY = ['domain', 'path']
#: Attribute display order.
ATTRIBUTE_DISPLAY_ORDER = ['domain', 'name', 'path', 'value', 'flags', 'expires', 'created']


def warning(*messages: str):
    """
    Display warning messages.

    Args:
        messages: warning messages
    """
    for message in messages:
        sys.stderr.write(f'WARNING: {message}\n')


def error(*messages: str):
    """
    Display error messages.

    Args:
        messages: error messages
    """
    for message in messages:
        sys.stderr.write(f'ERROR: {message}\n')


def abort(*messages: str):
    """
    Display error messages and quit.

    Args:
        messages: error messages
    """
    error(*messages)
    sys.exit(1)


@contextmanager
def open_binary_file(path: Path) -> Iterator[IO]:
    try:
        with path.open('rb') as file:
            yield file
    except PermissionError:
        abort('Permission denied opening file:',
              str(path),
              'Make sure there are no foreground or background browser processes.')
    except (IOError, OSError) as exc:
        abort('Unable to open file due to exception:', str(path), str(exc))


def get_filter_by(filter_exprs: Iterable[str]) -> FilterBy:
    """
    Convert name=value raw filter expressions to filter-by list.

    Values strings are HTTP-escaped. Multiple values may be comma-separated.

    Args:
        filter_exprs: name=value filter expressions

    Returns:
        dictionary mapping attribute names to lists of partial values
    """
    filters: list[Filter] = []
    for filter_expr in filter_exprs:
        filter_expr_parts = filter_expr.split('=', maxsplit=1)
        if len(filter_expr_parts) != 2 or not filter_expr_parts[1]:
            abort(f'Bad name=value filter expression: {filter_expr}')
        filters.append((filter_expr_parts[0], filter_expr_parts[1].split(',')))
    return filters


def filter_cookies(unfiltered_cookies: Iterable[Cookie],
                   filter_by: FilterBy | None,
                   ) -> Iterable[Cookie]:
    """
    Filter cookies.

    Filters are ANDed together. Filter values are ORed together.

    Args:
        unfiltered_cookies: unfiltered input cookies
        filter_by: optional (name, values) filter pairs

    Returns:
        iterable filtered cookies
    """
    if filter_by is None:
        return unfiltered_cookies
    # Lower-case the filter values for normalized comparison.
    filter_by = [(name, [value.lower() for value in values]) for name, values in filter_by]
    for cookie in unfiltered_cookies:
        for name, values in filter_by:
            if name not in cookie:
                break
            for value in values:
                # Normalize comparison by un-quoting and lower-casing cookie values.
                if unquote(cookie[name]).lower().find(value) == -1:
                    break
            else:
                continue
            break
        else:
            yield cookie


def sort_cookies(unsorted_cookies: Iterable[Cookie],
                 sort_by: SortBy | None,
                 ) -> Iterable[Cookie]:
    """
    Sort cookies.

    Args:
        unsorted_cookies: unsorted input cookies
        sort_by: optional attribute names to sort by in priority order

    Returns:
        iterable sorted cookies
    """
    if sort_by is None:
        return unsorted_cookies
    return sorted(unsorted_cookies, key=lambda c: [c[k] for k in sort_by])


def display_cookies(cookies: Iterable[Cookie]):
    """
    Display cookies.

    Args:
        cookies: iterable cookies to display
    """
    for cookie in cookies:
        # Don't assume all possible keys are present in cookie.
        keys1 = [key for key in ATTRIBUTE_DISPLAY_ORDER if key in cookie]
        keys2 = sorted([key for key in cookie.keys() if key not in keys1])
        print('')
        for key in keys1 + keys2:
            print(f'{key}={unquote(cookie[key])}')


class BinaryCookiesExtractor:
    """Binary cookies file reader and data extractor/decoder."""

    def __init__(self, stream: IO):
        """
        Binary cookies extractor constructor.

        Args:
            stream: file stream to read cookies from
        """
        self._stream = stream

    def get_bytes(self, length: int, expect: bytes = None) -> AnyStr:
        """
        Extract bytes from stream.

        Args:
            length: number of bytes
            expect: optional expected value to check

        Returns:
            extracted bytes
        """
        value = self._stream.read(length)
        if expect is not None and value != expect:
            abort(f'Expected bytes "{expect}", found "{value}".')
        return value

    def get_string(self, length: int, encoding: str = 'utf-8', expect: str = None) -> str:
        """
        Extract string from stream.

        Args:
            length: number of characters
            encoding: optional encoding (default: utf-8)
            expect: optional expected value to check

        Returns:
            extracted string value
        """
        raw_value = self.get_bytes(length)
        value = raw_value.decode(encoding)
        if expect is not None and value != expect:
            abort(f'Expected string "{expect}", found "{value}".')
        return value

    def get_header_integer(self) -> int:
        """
        Extract integer from stream header (big-endian integer format).

        Returns:
            extracted integer value
        """
        return unpack('>i', self.get_bytes(4))[0]

    def get_integer(self) -> int:
        """
        Extract integer from stream body (little-endian integer format).

        Returns:
            extracted integer value
        """
        return unpack('<i', self.get_bytes(4))[0]

    def get_flags(self) -> str:
        """
        Extract flag string from stream by checking flag integer bits.

        Returns:
            extracted flag string
        """
        flag_parts: list[str] = []
        flags = self.get_integer()
        if flags & 0x00000001:
            flag_parts.append('Secure')
        if flags & 0x00000004:
            flag_parts.append('HttpOnly')
        # if flags & 0xfffffffa:
        #     flag_parts.append(f'Unknown(0x{flags & 0xfffffffa:08x})')
        return '; '.join(flag_parts)

    def get_attribute(self) -> str:
        """
        Extract attribute value from stream.

        Returns:
            extracted attribute value
        """
        value = ''
        byte = self.get_bytes(1)
        while unpack('<b', byte)[0] != 0:
            value += byte.decode('utf-8')
            byte = self.get_bytes(1)
        return value

    def get_date_time(self) -> str:
        """
        Extract date/time string value from stream.

        Returns:
            extracted date/time string
        """
        # Expiry date is in Mac epoch format: Starts from 1/Jan/2001
        expiry_date_epoch = unpack('<d', self.get_bytes(8))[0] + 978307200
        # 978307200 is unix epoch of  1/Jan/2001
        return strftime('%c', gmtime(expiry_date_epoch))

    def get_block(self, length) -> Self:
        """
        Get sub-extractor for stream block.

        Args:
            length: block length

        Returns:
            block sub-extractor
        """
        return self.__class__(BytesIO(self.get_bytes(length)))

    def set_offset(self, offset: int):
        """
        Set stream offset (position).

        Args:
            offset: byte offset
        """
        self._stream.seek(offset)


def is_binary_cookies_file(path: Path) -> bool:
    """
    Check if file appears to be a binary cookies file.

    Args:
        path: file path

    Returns:
        True if the file contains binary cookies
    """
    with open_binary_file(path) as binary_file:
        extractor = BinaryCookiesExtractor(binary_file)
        if extractor.get_string(4, encoding='ascii') != 'cook':
            return False
        return True


def generate_binary_cookies(path: Path) -> Iterator[Cookie]:
    """
    Generate cookies by reading file and extracting individual cookies.

    Args:
        path: file path

    Returns:
        cookie iterator
    """
    with open_binary_file(path) as binary_file:
        extractor = BinaryCookiesExtractor(binary_file)
        extractor.get_string(4, encoding='ascii', expect='cook')
        num_pages = extractor.get_header_integer()
        page_sizes = [extractor.get_header_integer() for _idx in range(num_pages)]
        page_blocks = [extractor.get_block(length) for length in page_sizes]
        for page_block in page_blocks:
            page_block.get_bytes(4, expect=bytes([0, 0, 1, 0]))
            num_cookies = page_block.get_integer()
            cookie_offsets = [page_block.get_integer() for _idx in range(num_cookies)]
            page_block.get_bytes(4, expect=bytes([0, 0, 0, 0]))
            for offset in cookie_offsets:
                cookie = {}
                page_block.set_offset(offset)
                cookie_size = page_block.get_integer()
                cookie_block = page_block.get_block(cookie_size)
                cookie_block.get_bytes(4)  # unknown
                flags = cookie_block.get_flags()
                if flags:
                    cookie['flags'] = flags
                cookie_block.get_bytes(4)  # unknown
                url_offset = cookie_block.get_integer()
                name_offset = cookie_block.get_integer()
                path_offset = cookie_block.get_integer()
                value_offset = cookie_block.get_integer()
                cookie_block.get_bytes(8)  # end of cookie
                cookie['expires'] = cookie_block.get_date_time()
                cookie['created'] = cookie_block.get_date_time()
                cookie_block.set_offset(url_offset - 4)
                cookie['domain'] = cookie_block.get_attribute()
                cookie_block.set_offset(name_offset - 4)
                cookie['name'] = cookie_block.get_attribute()
                cookie_block.set_offset(path_offset - 4)
                cookie['path'] = cookie_block.get_attribute()
                cookie_block.set_offset(value_offset - 4)
                cookie['value'] = cookie_block.get_attribute()
                yield cookie


class SQLiteCookiesBase(ABC):
    """Base utility class for SQLite cookie access."""

    #: Named tuple that row data is assigned to.
    CanonicalRow = namedtuple(
        'CanonicalRow',
        [
            'domain',
            'name',
            'value',
            'path',
            'has_expires',
            'expires_utc',
            'creation_utc',
            'is_httponly',
            'is_secure',
        ]
    )

    #: Must be provided by the subclass.
    DatabaseRow: namedtuple = None

    def __init__(self, path: Path, table_name: str):
        """
        SQLiteCookiesBase constructor.

        Args:
            path: database file path
            table_name: cookies table name
        """
        self.path = path
        self.table_name = table_name
        assert self.DatabaseRow is not None
        # noinspection PyProtectedMember
        columns_string = ", ".join(self.DatabaseRow._fields)
        self.cookie_query = f'SELECT {columns_string} FROM {self.table_name}'

    def is_cookies_db(self) -> bool:
        """
        Check if file is a SQLite cookies database.

        Returns:
            True if file is a SQLite database
        """
        # First sanity-check that the file can be opened at all.
        with open_binary_file(self.path):
            pass
        # Then see if we can query it as a cookies database.
        try:
            connection = sqlite3.connect(self.path)
            try:
                cursor = connection.execute(
                    f"SELECT count(*) from sqlite_master "
                    f"WHERE type = 'table' and name = '{self.table_name}'"
                )
                try:
                    return cursor.fetchone()[0] == 1
                finally:
                    cursor.close()
            finally:
                connection.close()
        except sqlite3.Error:
            return False

    @abstractmethod
    def canonicalize_row(self, row: DatabaseRow) -> CanonicalRow:
        """
        Required method to convert database row to canonical row.
        Args:
            row: database row

        Returns:
            canonical row
        """
        ...

    def generate_cookies(self, filter_by: FilterBy, sort_by: SortBy) -> Iterable[Cookie]:
        """Required override: query cookies with optional filtering and sorting."""
        def _generate() -> Iterator[Cookie]:
            connection = sqlite3.connect(self.path)
            try:
                cursor = connection.cursor()
                try:
                    cursor.execute(self.cookie_query)
                    for raw_row in cursor:
                        row = self.canonicalize_row(self.DatabaseRow(*raw_row))
                        cookie = {
                            'domain': row.domain,
                            'name': row.name,
                            'value': row.value,
                            'path': row.path,
                        }
                        flag_parts: list[str] = []
                        if row.is_httponly:
                            flag_parts.append('HttpOnly')
                        if row.is_secure:
                            flag_parts.append('Secure')
                        if flag_parts:
                            cookie['flags'] = '; '.join(flag_parts)
                        if row.has_expires:
                            expires_gm = gmtime(row.expires_utc)
                            cookie['expires'] = strftime('%c', expires_gm)
                        if row.creation_utc:
                            creation_gm = gmtime(row.creation_utc)
                            cookie['created'] = strftime('%c', creation_gm)
                        yield cookie
                finally:
                    cursor.close()
            finally:
                connection.close()
        # Avoid excess memory consumption by passing generator to filtering/sorting.
        filtered_cookies = filter_cookies(_generate(), filter_by)
        return sort_cookies(filtered_cookies, sort_by)


class BrowserBase(ABC):
    """Abstract browser class."""

    name: str = None

    def __init__(self, file_path: Path):
        """
        Browser base constructor.

        Args:
            file_path: cookies file or database path
        """
        self.file_path = file_path

    @classmethod
    @abstractmethod
    def from_file(cls, path: Path) -> Self | None:
        """
        Required conditional factory method..

        Args:
            path: file path

        Returns:
            browser instance if the file belongs to browser
        """
        ...

    @classmethod
    @abstractmethod
    def find_cookies(cls, profile: str | None) -> Path | None:
        """
        Required method to find the cookies file.

        Args:
            profile: optional profile name

        Returns:
            cookies file path if found
        """
        ...

    @abstractmethod
    def generate_cookies(self, filter_by: FilterBy, sort_by: SortBy) -> Iterable[Cookie]:
        """
        Required method to generate cookies with optional filtering and sorting.

        Args:
            filter_by: filters as a mapping of attribute names to filtered values
            sort_by: sort by named attributes in order provided
        """
        ...

    @classmethod
    def find_file(cls, location_map: LocationMap) -> Path | None:
        """
        Utility method to search for a file given multiple possible platform-specific paths.

        Args:
            location_map: possible file locations mapped by platform

        Returns:
            found path
        """
        if sys.platform not in location_map:
            return None
        for path in location_map[sys.platform]:
            path = Path(path).expanduser()
            if path.is_file():
                return path
        return None


class SafariBrowser(BrowserBase):
    """Safari browser implementation."""

    name = 'Safari'

    cookies_paths: LocationMap = {
        'darwin': [
            '~/Library/Containers/com.apple.Safari/Data/Library/Cookies/Cookies.binarycookies',
            '~/Library/Cookies/Cookies.binarycookies',
        ],
    }

    @classmethod
    def from_file(cls, path: Path) -> Self | None:
        """Required conditional factory method."""
        return cls(path) if is_binary_cookies_file(path) else None

    @classmethod
    def find_cookies(cls, profile: str | None) -> Path | None:
        """Required method to locate the cookies file."""
        return cls.find_file(cls.cookies_paths)

    def generate_cookies(self, filter_by: FilterBy, sort_by: SortBy) -> Iterable[Cookie]:
        """Required override: query cookies with optional filtering and sorting."""
        filtered_cookies = filter_cookies(generate_binary_cookies(self.file_path), filter_by)
        return sort_cookies(filtered_cookies, sort_by)


class GenericChromeBrowser(BrowserBase):
    """Generic Chrome-based browser implementation."""

    name = 'Chrome (generic)'

    # Should be overridden.
    db_paths: LocationMap = {}

    class SQLiteCookies(SQLiteCookiesBase):

        DatabaseRow = namedtuple(
            'DatabaseRow',
            [
                'host_key',
                'name',
                'encrypted_value',
                'path',
                'has_expires',
                'expires_utc',
                'creation_utc',
                'is_httponly',
                'is_secure',
            ],
        )

        def __init__(self, path: Path):
            """
            SQLiteCookies constructor.

            Args:
                path: cookies database file path
            """
            super().__init__(path, 'cookies')

        def canonicalize_row(self, row: DatabaseRow) -> SQLiteCookiesBase.CanonicalRow:
            return SQLiteCookiesBase.CanonicalRow(
                domain=row.host_key,
                name=row.name,
                value=f'encrypted(length={len(row.encrypted_value)})',
                path=row.path,
                has_expires=row.has_expires,
                expires_utc=row.expires_utc / 1000000 - 11644473600,
                creation_utc=row.creation_utc / 1000000 - 11644473600,
                is_httponly=row.is_httponly,
                is_secure=row.is_secure,
            )

    def __init__(self, file_path: Path, cookies_db: SQLiteCookies):
        """
        Browser base constructor.

        Args:
            file_path: cookies file or database path
        """
        super().__init__(file_path)
        self.cookies_db = cookies_db

    @classmethod
    def from_file(cls, path: Path) -> Self | None:
        """Required conditional factory method."""
        cookies_db = cls.SQLiteCookies(path)
        if not cookies_db.is_cookies_db():
            return None
        return cls(path, cookies_db)

    @classmethod
    def find_cookies(cls, profile: str | None) -> Path | None:
        """Required override to locate the cookies database."""
        return cls.find_file(cls.db_paths)

    def generate_cookies(self, filter_by: FilterBy, sort_by: SortBy) -> Iterable[Cookie]:
        """Required override to generate cookies."""
        return self.cookies_db.generate_cookies(filter_by, sort_by)


class ChromeBrowser(GenericChromeBrowser):
    """Chrome browser implementation."""
    name = 'Chrome'
    db_paths: LocationMap = {
        'darwin': [
            '~/Library/Application Support/Google/Chrome/Default/Cookies',
        ],
        'linux': [
            '~/.config/chrome/Cookies',
        ],
        'win32': [
            '~/AppData/Local/Google/Chrome/User Data/Default/Network/Cookies',
        ],
    }


class EdgeBrowser(GenericChromeBrowser):
    """Microsoft Edge browser implementation."""
    name = 'Edge'
    db_paths: LocationMap = {
        'win32': [
            '~/AppData/Local/Microsoft/Edge/User Data/Default/Network/Cookies',
        ],
    }


class ChromiumBrowser(GenericChromeBrowser):
    """Chromium browser implementation."""
    name = 'Chromium'
    db_paths: LocationMap = {
        'linux': [
            '~/.config/chromium/Default/Cookies',
        ],
    }


class FirefoxBrowser(BrowserBase):
    """Firefox browser implementation."""

    name = 'Firefox'

    profiles_ini_paths: LocationMap = {
        'darwin': [
            '~/Library/Application Support/Firefox/profiles.ini',
        ],
        'linux': [
            '~/.mozilla/firefox/profiles.ini',
        ],
        'win32': [
            '~/AppData/Roaming/Mozilla/Firefox/profiles.ini',
        ],
    }

    class SQLiteCookies(SQLiteCookiesBase):

        DatabaseRow = namedtuple(
            'DatabaseRow',
            [
                'host',
                'name',
                'value',
                'path',
                'expiry',
                'creationTime',
                'isHttpOnly',
                'isSecure',
            ],
        )

        def __init__(self, path: Path):
            """
            SQLiteCookies constructor.

            Args:
                path: cookies database file path
            """
            super().__init__(path, 'moz_cookies')

        def canonicalize_row(self, row: DatabaseRow) -> SQLiteCookiesBase.CanonicalRow:
            return SQLiteCookiesBase.CanonicalRow(
                domain=row.host,
                name=row.name,
                value=row.value,
                path=row.path,
                has_expires=row.expiry,
                expires_utc=row.expiry,
                creation_utc=row.creationTime / 1000000,
                is_httponly=row.isHttpOnly,
                is_secure=row.isSecure,
            )

    def __init__(self, file_path: Path, cookies_db: SQLiteCookies):
        """
        Browser base constructor.

        Args:
            file_path: cookies file or database path
        """
        super().__init__(file_path)
        self.cookies_db = cookies_db

    @classmethod
    def from_file(cls, path: Path) -> Self | None:
        """Required conditional factory method."""
        cookies_db = cls.SQLiteCookies(path)
        if not cookies_db.is_cookies_db():
            return None
        return cls(path, cookies_db)

    @classmethod
    def find_cookies(cls, profile: str | None) -> Path | None:
        """Required override to find the cookies database file."""
        # NB: Firefox seems to be a bit flakey with how it handles finding the
        # active profile. So in some cases users may need to explicitly specify
        # a profile, because the default may not actually be active.
        profiles = ConfigParser()
        profiles_ini_path = cls.find_file(cls.profiles_ini_paths)
        if profiles_ini_path is None:
            error(f'Unable to find Firefox profiles configuration.')
            return None
        parsed_files = profiles.read(profiles_ini_path)
        if not parsed_files:
            error(f'Unable to parse Firefox profiles configuration: {profiles_ini_path}')
            return None
        # Find the cookies database path.
        if profile:
            # Match specific profile.
            for section in profiles.sections():
                if profiles.get(section, 'Name', fallback=None) == profile:
                    cookies_db_path = profiles.get(section, 'Path', fallback=None)
                    if cookies_db_path is not None:
                        if profiles.get(section, 'IsRelative', fallback=None):
                            return profiles_ini_path.parent / cookies_db_path
                        return Path(cookies_db_path)
                    return None
        # Otherwise look for default profile with cookie file.
        for section in profiles.sections():
            name = profiles.get(section, 'Name', fallback=None)
            default = profiles.get(section, 'Default', fallback=None)
            if default:
                # Handle the complication of an "Install..." profile providing
                # the active path via the "Default" attribute. That path may be
                # relative without an "IsRelative" attribute to flag as such.
                if default != '1':
                    cookies_db_path = Path(default) / 'cookies.sqlite'
                    if cookies_db_path.is_file():
                        return cookies_db_path
                    return profiles_ini_path.parent / cookies_db_path
                cookies_db_path = profiles.get(section, 'Path', fallback=None)
                if cookies_db_path:
                    if profiles.get(section, 'IsRelative', fallback=None):
                        cookies_db_path = profiles_ini_path.parent / cookies_db_path
                    else:
                        cookies_db_path = Path(cookies_db_path)
                    if cookies_db_path.is_file():
                        return cookies_db_path
        return None

    def generate_cookies(self, filter_by: FilterBy, sort_by: SortBy) -> Iterable[Cookie]:
        """Required override to generate cookies."""
        return self.cookies_db.generate_cookies(filter_by, sort_by)


NAMED_BROWSERS: dict[str, type[BrowserBase]] = {
    'chrome': ChromeBrowser,
    'chromium': ChromiumBrowser,
    'edge': EdgeBrowser,
    'firefox': FirefoxBrowser,
    'safari': SafariBrowser,
}

FILE_CHECK_BROWSERS: list[type[BrowserBase]] = [
    GenericChromeBrowser,
    FirefoxBrowser,
    SafariBrowser,
    ChromiumBrowser,
]


def get_browser_for_cookie_source(cookie_source: str) -> BrowserBase:
    """
    Get browser object based on cookie source (file path or browser name).

    Args:
        cookie_source: file path or browser name

    Returns:
        browser object for processing query
    """
    if os.path.isfile(cookie_source):
        file_path = Path(cookie_source)
        for browser_class in FILE_CHECK_BROWSERS:
            browser = browser_class.from_file(file_path)
            if browser is not None:
                return browser
        abort('Unable to identify browser for file provided.')
    if os.path.sep in cookie_source:
        abort('File not found.')
    cookie_source_parts = cookie_source.lower().split(':', maxsplit=1)
    if len(cookie_source_parts) == 2:
        browser_name, profile = cookie_source_parts
    else:
        browser_name, profile = cookie_source_parts[0], None
    browser_name = browser_name.lower()
    if browser_name not in NAMED_BROWSERS:
        abort(f'Browser not supported: {browser_name}')
    browser_class = NAMED_BROWSERS[browser_name]
    file_path = browser_class.find_cookies(profile)
    if file_path is None:
        abort(f'{browser_class.name} cookies file not found.')
    browser = browser_class.from_file(file_path)
    if browser is None:
        abort(f'{browser_class.name} browser class did not recognize cookies file.',
              str(file_path))
    return browser


def main():
    """Main function."""
    epilog_parts = [CLI_EPILOG] + [f'  - {name}' for name in sorted(NAMED_BROWSERS.keys())]
    arg_parser = argparse.ArgumentParser(
        description=CLI_DESCRIPTION,
        epilog=os.linesep.join(epilog_parts),
        formatter_class=argparse.RawTextHelpFormatter,
    )
    arg_parser.add_argument(dest='COOKIE_SOURCE', help=COOKIE_SOURCE_HELP)
    arg_parser.add_argument(dest='FILTER', nargs='*', help=FILTER_HELP)
    args = arg_parser.parse_args()
    filter_by = get_filter_by(args.FILTER)
    browser = get_browser_for_cookie_source(args.COOKIE_SOURCE)
    cookies = browser.generate_cookies(filter_by=filter_by, sort_by=DEFAULT_SORT_BY)
    print(f'=== {browser.name}: {browser.file_path} ===')
    display_cookies(cookies)


if __name__ == '__main__':
    main()
